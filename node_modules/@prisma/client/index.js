const { execFileSync } = require('child_process');
const path = require('path');
const fs = require('fs');

const DEFAULT_DB = path.join(process.cwd(), 'prisma', 'dev.db');

const resolveDbPath = (url) => {
  if (!url) {
    return DEFAULT_DB;
  }
  if (url.startsWith('file:')) {
    const relative = url.replace('file:', '');
    return path.resolve(process.cwd(), relative);
  }
  return path.resolve(process.cwd(), url);
};

const ensureDatabase = (dbPath) => {
  const dir = path.dirname(dbPath);
  fs.mkdirSync(dir, { recursive: true });
  if (!fs.existsSync(dbPath)) {
    fs.closeSync(fs.openSync(dbPath, 'w'));
  }
};

const formatParamValue = (value) => {
  if (value === null || value === undefined) {
    return 'NULL';
  }
  return JSON.stringify(value);
};

class SQLiteClient {
  constructor(dbPath) {
    this.dbPath = dbPath;
  }

  _buildArgs(sql, params = {}) {
    const args = ['-json', this.dbPath, '-cmd', 'PRAGMA foreign_keys = ON'];

    const entries = Object.entries(params);
    if (entries.length) {
      args.push('-cmd', '.parameter init');
      for (const [key, value] of entries) {
        args.push('-cmd', `.parameter set :${key} ${formatParamValue(value)}`);
      }
    }

    args.push(sql);
    return args;
  }

  query(sql, params = {}) {
    const args = this._buildArgs(sql, params);
    const output = execFileSync('sqlite3', args, { encoding: 'utf8' }).trim();
    if (!output) {
      return [];
    }
    try {
      return JSON.parse(output);
    } catch (error) {
      throw new Error(`Failed to parse SQLite output: ${error.message}\n${output}`);
    }
  }

  run(sql, params = {}) {
    const args = this._buildArgs(sql, params);
    execFileSync('sqlite3', args, { encoding: 'utf8' });
  }
}

const mapGroup = (row) => {
  if (!row) return null;
  return {
    id: row.id,
    name: row.name,
    subtitle: row.subtitle || null,
    description: row.description || null,
    coverImage: row.coverImage || null,
    createdAt: row.createdAt,
    updatedAt: row.updatedAt
  };
};

const mapCard = (row) => {
  if (!row) return null;
  return {
    id: row.id,
    translation: row.translation,
    original: row.original || null,
    image: row.image || null,
    groupId: row.groupId,
    createdAt: row.createdAt,
    updatedAt: row.updatedAt
  };
};

class PrismaClient {
  constructor(options = {}) {
    const datasourceUrl = process.env.DATABASE_URL || options.datasourceUrl;
    this.dbPath = resolveDbPath(datasourceUrl || 'file:./prisma/dev.db');
    ensureDatabase(this.dbPath);
    this.client = new SQLiteClient(this.dbPath);

    this.group = {
      findMany: async (args = {}) => {
        const groups = this.client.query(
          `SELECT id, name, subtitle, description, cover_image AS coverImage, created_at AS createdAt, updated_at AS updatedAt
           FROM groups
           ORDER BY id;`
        ).map(mapGroup);

        if (!args.include || !args.include.cards) {
          return groups;
        }

        const ids = groups.map((group) => group.id);
        if (!ids.length) {
          return groups;
        }

        const placeholders = ids.map((_, index) => `:id${index}`);
        const params = ids.reduce((acc, value, index) => {
          acc[`id${index}`] = value;
          return acc;
        }, {});

        const cards = this.client
          .query(
            `SELECT id, translation, original, image, group_id AS groupId, created_at AS createdAt, updated_at AS updatedAt
             FROM cards
             WHERE group_id IN (${placeholders.join(', ')})
             ORDER BY id;`,
            params
          )
          .map(mapCard);

        const cardsByGroup = cards.reduce((acc, card) => {
          if (!acc[card.groupId]) {
            acc[card.groupId] = [];
          }
          acc[card.groupId].push(card);
          return acc;
        }, {});

        return groups.map((group) => ({
          ...group,
          cards: cardsByGroup[group.id] || []
        }));
      },
      findUnique: async (args = {}) => {
        if (!args.where) {
          throw new Error('group.findUnique requires a where clause');
        }
        let whereClause = '';
        const params = {};
        if (args.where.id !== undefined) {
          whereClause = 'id = :id';
          params.id = args.where.id;
        } else if (args.where.name !== undefined) {
          whereClause = 'name = :name';
          params.name = args.where.name;
        } else {
          throw new Error('Unsupported where clause for group.findUnique');
        }

        const rows = this.client.query(
          `SELECT id, name, subtitle, description, cover_image AS coverImage, created_at AS createdAt, updated_at AS updatedAt
           FROM groups
           WHERE ${whereClause}
           LIMIT 1;`,
          params
        );

        const group = mapGroup(rows[0]);
        if (!group) {
          return null;
        }

        if (args.include && args.include.cards) {
          const cards = await this.card.findMany({
            where: { groupId: group.id }
          });
          group.cards = cards;
        }

        return group;
      },
      create: async ({ data, include } = {}) => {
        if (!data || !data.name) {
          throw new Error('group.create requires data with a name');
        }

        const rows = this.client.query(
          `INSERT INTO groups (name, subtitle, description, cover_image, created_at, updated_at)
           VALUES (:name, :subtitle, :description, :coverImage, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);
           SELECT id, name, subtitle, description, cover_image AS coverImage, created_at AS createdAt, updated_at AS updatedAt
           FROM groups
           WHERE id = last_insert_rowid();`,
          {
            name: data.name,
            subtitle: data.subtitle ?? null,
            description: data.description ?? null,
            coverImage: data.coverImage ?? null
          }
        );

        const group = mapGroup(rows[0]);

        if (include && include.cards) {
          group.cards = [];
        }

        return group;
      }
    };

    this.card = {
      findMany: async (args = {}) => {
        const where = args.where || {};
        let whereClause = '';
        const params = {};
        if (where.groupId !== undefined) {
          whereClause = 'WHERE group_id = :groupId';
          params.groupId = where.groupId;
        }
        const rows = this.client.query(
          `SELECT id, translation, original, image, group_id AS groupId, created_at AS createdAt, updated_at AS updatedAt
           FROM cards
           ${whereClause}
           ORDER BY id;`,
          params
        );
        return rows.map(mapCard);
      },
      create: async ({ data } = {}) => {
        if (!data || !data.translation || !data.groupId) {
          throw new Error('card.create requires data with translation and groupId');
        }

        const rows = this.client.query(
          `INSERT INTO cards (translation, original, image, group_id, created_at, updated_at)
           VALUES (:translation, :original, :image, :groupId, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);
           SELECT id, translation, original, image, group_id AS groupId, created_at AS createdAt, updated_at AS updatedAt
           FROM cards
           WHERE id = last_insert_rowid();`,
          {
            translation: data.translation,
            original: data.original ?? null,
            image: data.image ?? null,
            groupId: data.groupId
          }
        );

        return mapCard(rows[0]);
      }
    };
  }

  async $connect() {
    return true;
  }

  async $disconnect() {
    return true;
  }
}

module.exports = { PrismaClient };
